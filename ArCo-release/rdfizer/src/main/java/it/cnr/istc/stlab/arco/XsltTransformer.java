package it.cnr.istc.stlab.arco;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.util.concurrent.ConcurrentMap;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Option.Builder;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.mapdb.DB;
import org.mapdb.DBMaker;
import org.mapdb.Serializer;

import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;

public class XsltTransformer {

	private static final String OUTPUT_FILE = "o";
    private static final String OUTPUT_FILE_LONG = "output";
    
    private static final String OUTPUT_SYNTAX = "s";
    private static final String OUTPUT_SYNTAX_LONG = "syntax";
    
    public static void main(String[] args) throws FileNotFoundException {
		Converter converter = new Converter();
		
		try{
			/*
	         * Set-up the options for the command line parser.
	         */
	        Options options = new Options();
	        
	        Builder optionBuilder = Option.builder(OUTPUT_FILE);
	        Option outputFileOption = optionBuilder.argName("file")
	                                 .hasArg()
	                                 .required(false)
	                                 .desc("OPTIONAL - Output file generated by the application.")
	                                 .longOpt(OUTPUT_FILE_LONG)
	                                 .build();
	        
	        optionBuilder = Option.builder(OUTPUT_SYNTAX);
	        Option outputSyntaxOption = optionBuilder.argName("string")
	                                 .hasArg()
	                                 .required(false)
	                                 .desc("OPTIONAL - RDF syntax of the resulting transformation.")
	                                 .longOpt(OUTPUT_SYNTAX_LONG)
	                                 .build();
	        
	        
	        
	        options.addOption(outputFileOption);
	        options.addOption(outputSyntaxOption);
	        
	        CommandLine commandLine = null;
	        
	        CommandLineParser cmdLineParser = new DefaultParser();
	        try {
	            commandLine = cmdLineParser.parse(options, args);
	        } catch (ParseException e) {
	            HelpFormatter formatter = new HelpFormatter();
	            formatter.printHelp( "process", options );
	        }
	        
	        if(commandLine != null){
	        	
	        	String[] arguments = commandLine.getArgs();
	        	if(arguments != null && arguments.length > 0){
	        		File xmlIn = new File(arguments[0]);
	        		if(xmlIn.exists()){
	        			if(xmlIn.isFile()){
	        				if(xmlIn.getName().endsWith(".xml")){
	        					String fileName = xmlIn.getName().replace(".xml", "");
	        					InputStream inputStream = new FileInputStream(xmlIn);
	        					
	        					OutputStream out = null;
	        					String outputDestination = commandLine.getOptionValue(OUTPUT_FILE);
	        					if(outputDestination != null){
	        						File output = new File(outputDestination);
	        						out = new FileOutputStream(output);
	        					}
	        					else out = System.out;
	        					
	        					String outputSyntax = commandLine.getOptionValue(OUTPUT_SYNTAX);
	        					if(outputSyntax == null)
	        						outputSyntax = "TURTLE";
	        					
	        					ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream();
								converter.convert(fileName, inputStream, byteArrayOut);
								
								String rdfSource = new String(byteArrayOut.toByteArray());
								//System.out.println(rdfSource);
								
								ByteArrayInputStream in = new ByteArrayInputStream(rdfSource.getBytes());
								
								Model model = ModelFactory.createDefaultModel();
								model.read(in, null, "RDF/XML");
								model.write(out, outputSyntax);
	        				}
	        				else System.err.println("The XML file provided as input is not XML: the application processes only file with .xml extension.");
	        			}
	        			else System.err.println("The XML file provided as input does not exist is not a file.");
	        		}
	        		else System.err.println("The XML file provided as input does not exist.");
	        	}
	        	else System.err.println("No XML file provided as input.");
	        }
		}
        
        finally {
        	converter.destroy();
		}
        
	}
	
}
